{
    "sourceFile": "src/controllers/pairing.controller.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746681926868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746681926868,
            "name": "Commit-0",
            "content": "import { Request, Response } from 'express';\nimport { prisma } from '../server';\nimport { Parser } from 'json2csv';\nimport { sendPrayerPartnerNotification, sendReminderEmails as sendReminderEmailsCampaign } from '../services/email.service';\nimport { sendSuccess, sendError } from '../utils/response.util';\nimport { toNumber } from '../utils/type.util';\nimport { BadRequestError, NotFoundError } from '../utils/errors.util';\nimport logger from '../utils/logger.util';\nimport { Prisma, PrayerRequest } from '@prisma/client'; // Added Prisma and PrayerRequest\n\n// Define complex types for Prisma payloads\ntype PairingForGetCurrentPartner = Prisma.PrayerPairingGetPayload<{\n  include: {\n    partner1: { select: { id: true, firstName: true, lastName: true, email: true } },\n    partner2: { select: { id: true, firstName: true, lastName: true, email: true } },\n    theme: true,\n    request: true,\n  }\n}>;\n\ntype PairingForExport = Prisma.PrayerPairingGetPayload<{\n  include: {\n    partner1: {\n      select: {\n        firstName: true,\n        lastName: true,\n        email: true,\n        prayerRequests: {\n          where: { isActive: true },\n          orderBy: { createdAt: 'desc' },\n          take: 1,\n        },\n      },\n    },\n    partner2: {\n      select: {\n        firstName: true,\n        lastName: true,\n        email: true,\n        prayerRequests: {\n          where: { isActive: true },\n          orderBy: { createdAt: 'desc' },\n          take: 1,\n        },\n      },\n    },\n    theme: {\n      select: {\n        title: true,\n        description: true,\n      },\n    },\n    request: true,\n  }\n}>;\n\n// Get all pairings\nexport const getAllPairings = async (req: Request, res: Response) => {\n  try {\n    const pairings = await prisma.prayerPairing.findMany({\n      include: {\n        partner1: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true,\n          },\n        },\n        partner2: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true,\n          },\n        },\n        theme: true,\n        request: true,\n      },\n      orderBy: { startDate: 'desc' },\n    });\n\n    sendSuccess(res, 200, 'Pairings retrieved successfully', pairings);\n  } catch (error) {\n    logger.error('Get pairings error', {\n      error: error instanceof Error ? error.message : 'Unknown error',\n      stack: error instanceof Error ? error.stack : undefined\n    });\n    sendError(res, 500, 'Server error while fetching pairings',\n      error instanceof Error ? error.message : 'Unknown error');\n  }\n};\n\n// Get current pairings (active based on date)\nexport const getCurrentPairings = async (req: Request, res: Response) => {\n  try {\n    const currentDate = new Date();\n    logger.debug('Fetching current pairings', { date: currentDate });\n\n    const pairings = await prisma.prayerPairing.findMany({\n      where: {\n        startDate: { lte: currentDate },\n        endDate: { gte: currentDate },\n      },\n      include: {\n        partner1: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true,\n          },\n        },\n        partner2: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true,\n          },\n        },\n        theme: true,\n        request: true,\n      },\n      orderBy: { startDate: 'desc' },\n    });\n\n    logger.debug('Current pairings found', { count: pairings.length });\n    sendSuccess(res, 200, 'Current pairings retrieved successfully', pairings);\n  } catch (error) {\n    logger.error('Get current pairings error', {\n      error: error instanceof Error ? error.message : 'Unknown error',\n      stack: error instanceof Error ? error.stack : undefined\n    });\n    sendError(res, 500, 'Server error while fetching current pairings',\n      error instanceof Error ? error.message : 'Unknown error');\n  }\n};\n\n// Get pairing history for a specific user\nexport const getUserPairingHistory = async (req: Request, res: Response) => {\n  try {\n    if (!req.user) {\n      return sendError(res, 401, 'User not authenticated');\n    }\n    const userId = parseInt(req.params.userId) || req.user.id;\n\n    const pairings = await prisma.prayerPairing.findMany({\n      where: {\n        OR: [\n          { partner1Id: userId },\n          { partner2Id: userId },\n        ],\n      },\n      include: {\n        partner1: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true,\n          },\n        },\n        partner2: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true,\n          },\n        },\n        theme: true,\n        request: true,\n      },\n      orderBy: { startDate: 'desc' },\n    });\n\n    res.status(200).json(pairings);\n    return;\n  } catch (error) {\n    console.error('Get user pairing history error:', error);\n    res.status(500).json({ message: 'Server error while fetching user pairing history' });\n    return;\n  }\n};\n\n// Get current prayer partner for a user\nexport const getCurrentPartner = async (req: Request, res: Response) => {\n  // Initialize userId with a default value before the try block\n  let userId: number = -1; // Default value indicating uninitialized userId\n\n  try {\n    if (!req.user) {\n      return sendError(res, 401, 'User not authenticated');\n    }\n    userId = toNumber(req.params.userId || req.user.id);\n    const currentDate = new Date();\n\n    // Find pairings where the user is partner1 (the one praying for someone)\n    const pairings = await prisma.prayerPairing.findMany({\n      where: {\n        partner1Id: userId,\n        startDate: { lte: currentDate },\n        endDate: { gte: currentDate },\n      },\n      include: {\n        partner1: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true,\n          },\n        },\n        partner2: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true,\n          },\n        },\n        theme: true,\n        request: true,\n      },\n    });\n\n    if (pairings.length === 0) {\n      // If no pairings found as partner1, check if user is partner2\n      logger.debug('No pairings found for user as partner1', { userId });\n      sendError(res, 404, 'No current prayer partner found');\n      return;\n    }\n\n    // Get the active prayer requests for each partner2\n    const partnerIds = pairings.map((pairing: PairingForGetCurrentPartner) => pairing.partner2Id);\n\n    const partnerRequests = await prisma.prayerRequest.findMany({\n      where: {\n        userId: { in: partnerIds },\n        isActive: true,\n      },\n    });\n\n    logger.debug('Active prayer requests found for partners', {\n      count: partnerRequests.length,\n      partnerIds\n    });\n\n    // Format the response\n    const formattedPairings = pairings.map((pairing: PairingForGetCurrentPartner) => {\n      // Find the active prayer request for this partner\n      const partnerRequest = partnerRequests.find(\n        (request: PrayerRequest) => request.userId === pairing.partner2Id\n      );\n\n      return {\n        pairing: {\n          id: pairing.id,\n          startDate: pairing.startDate,\n          endDate: pairing.endDate,\n          theme: pairing.theme,\n          isSpecialPairing: pairing.isSpecialPairing,\n        },\n        partner: pairing.partner2,\n        prayerRequest: partnerRequest || pairing.request,\n      };\n    });\n\n    sendSuccess(res, 200, 'Current prayer partner retrieved successfully', formattedPairings);\n  } catch (error) {\n    logger.error('Get current partner error', {\n      error: error instanceof Error ? error.message : 'Unknown error',\n      stack: error instanceof Error ? error.stack : undefined,\n      userId: userId !== -1 ? userId : 'unknown' // Use default value if uninitialized\n    });\n    sendError(res, 500, 'Server error while fetching current partner',\n      error instanceof Error ? error.message : 'Unknown error');\n  }\n};\n\n// Create a new pairing manually\nexport const createPairing = async (req: Request, res: Response) => {\n  try {\n    const { partner1Id, partner2Id, themeId, startDate, endDate, requestId, isSpecialPairing } = req.body;\n\n    // Validate that partners are different\n    if (partner1Id === partner2Id) {\n      res.status(400).json({ message: 'Partners must be different users' });\n      return;\n    }\n\n    // Check if users exist and are active\n    const partner1 = await prisma.user.findUnique({\n      where: { id: partner1Id, active: true },\n    });\n\n    const partner2 = await prisma.user.findUnique({\n      where: { id: partner2Id, active: true },\n    });\n\n    if (!partner1 || !partner2) {\n      res.status(400).json({ message: 'One or both partners not found or inactive' });\n      return;\n    }\n\n    // Check if theme exists\n    const theme = await prisma.prayerTheme.findUnique({\n      where: { id: themeId, active: true },\n    });\n\n    if (!theme) {\n      res.status(400).json({ message: 'Theme not found or inactive' });\n      return;\n    }\n\n    // Check if prayer request exists if provided\n    if (requestId) {\n      const prayerRequest = await prisma.prayerRequest.findUnique({\n        where: { id: requestId },\n      });\n\n      if (!prayerRequest) {\n        res.status(400).json({ message: 'Prayer request not found' });\n        return;\n      }\n    }\n\n    // Create the pairing\n    const newPairing = await prisma.prayerPairing.create({\n      data: {\n        partner1Id,\n        partner2Id,\n        themeId,\n        startDate: new Date(startDate),\n        endDate: new Date(endDate),\n        requestId: requestId || null,\n        isSpecialPairing: isSpecialPairing || false,\n      },\n      include: {\n        partner1: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true,\n          },\n        },\n        partner2: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true,\n          },\n        },\n        theme: true,\n        request: true,\n      },\n    });\n\n    res.status(201).json({\n      message: 'Prayer pairing created successfully',\n      pairing: newPairing,\n    });\n    return;\n  } catch (error) {\n    console.error('Create pairing error:', error);\n    res.status(500).json({ message: 'Server error while creating pairing' });\n    return;\n  }\n};\n\n// Generate pairings for all active users\nexport const generatePairings = async (req: Request, res: Response) => {\n  try {\n    const { startDate, endDate, themeId } = req.body;\n\n    // Convert themeId to number using the utility function\n    const themeIdNumber = toNumber(themeId);\n\n    if (themeIdNumber === 0) {\n      throw new BadRequestError('Invalid theme ID format');\n    }\n\n    // Check if theme exists\n    const theme = await prisma.prayerTheme.findUnique({\n      where: { id: themeIdNumber, active: true },\n    });\n\n    if (!theme) {\n      throw new NotFoundError('Prayer theme');\n    }\n\n    // First, clear any existing pairings that overlap with the new date range\n    const newStartDate = new Date(startDate);\n    const newEndDate = new Date(endDate);\n\n    logger.info('Clearing existing pairings that overlap with date range', {\n      startDate: newStartDate,\n      endDate: newEndDate\n    });\n\n    // Delete pairings that overlap with the new date range\n    const deleteResult = await prisma.prayerPairing.deleteMany({\n      where: {\n        OR: [\n          // Pairings that start during the new range\n          {\n            startDate: {\n              gte: newStartDate,\n              lte: newEndDate\n            }\n          },\n          // Pairings that end during the new range\n          {\n            endDate: {\n              gte: newStartDate,\n              lte: newEndDate\n            }\n          },\n          // Pairings that completely contain the new range\n          {\n            startDate: { lte: newStartDate },\n            endDate: { gte: newEndDate }\n          }\n        ]\n      }\n    });\n\n    logger.info('Cleared existing pairings', { count: deleteResult.count });\n\n    // Get all active users with their active prayer requests\n    const activeUsers = await prisma.user.findMany({\n      where: { active: true },\n      include: {\n        prayerRequests: {\n          where: { isActive: true },\n          orderBy: { createdAt: 'desc' },\n          take: 1,\n        },\n      },\n    });\n\n    if (activeUsers.length < 2) {\n      throw new BadRequestError('Not enough active users to create pairings');\n    }\n\n    // Shuffle users for random pairing\n    const shuffledUsers = [...activeUsers].sort(() => Math.random() - 0.5);\n\n    // Create pairings array to store all created pairings\n    const pairings = [];\n\n    // Handle odd number of members\n    if (shuffledUsers.length % 2 !== 0) {\n      // The last person will be paired with two others\n      const specialUser = shuffledUsers.pop();\n\n      if (!specialUser) {\n        res.status(500).json({ message: 'Error handling odd number of users' });\n        return;\n      }\n\n      // Create two special pairings for this user\n      // First pairing: specialUser prays for the first user\n      const firstPartner = shuffledUsers[0];\n\n      // Get the prayer request for the first partner if it exists\n      const firstPartnerRequestId = firstPartner.prayerRequests.length > 0\n        ? firstPartner.prayerRequests[0].id\n        : null;\n\n      const firstPairing = await prisma.prayerPairing.create({\n        data: {\n          partner1Id: specialUser.id,\n          partner2Id: firstPartner.id,\n          themeId: themeIdNumber,\n          startDate: new Date(startDate),\n          endDate: new Date(endDate),\n          isSpecialPairing: true,\n          requestId: firstPartnerRequestId,\n        },\n      });\n\n      pairings.push(firstPairing);\n\n      // Second pairing: specialUser prays for the second user\n      const secondPartner = shuffledUsers[1];\n\n      // Get the prayer request for the second partner if it exists\n      const secondPartnerRequestId = secondPartner.prayerRequests.length > 0\n        ? secondPartner.prayerRequests[0].id\n        : null;\n\n      const secondPairing = await prisma.prayerPairing.create({\n        data: {\n          partner1Id: specialUser.id,\n          partner2Id: secondPartner.id,\n          themeId: themeIdNumber,\n          startDate: new Date(startDate),\n          endDate: new Date(endDate),\n          isSpecialPairing: true,\n          requestId: secondPartnerRequestId,\n        },\n      });\n\n      pairings.push(secondPairing);\n    }\n\n    // Create regular pairings for the remaining users\n    for (let i = 0; i < shuffledUsers.length; i += 2) {\n      // If we're at the end with an odd number, we've already handled it\n      if (i + 1 >= shuffledUsers.length) break;\n\n      const partner1 = shuffledUsers[i];\n      const partner2 = shuffledUsers[i + 1];\n\n      // Get prayer requests for both partners if they exist\n      const partner1RequestId = partner1.prayerRequests.length > 0\n        ? partner1.prayerRequests[0].id\n        : null;\n\n      const partner2RequestId = partner2.prayerRequests.length > 0\n        ? partner2.prayerRequests[0].id\n        : null;\n\n      // Create pairing where partner1 prays for partner2\n      const pairing1 = await prisma.prayerPairing.create({\n        data: {\n          partner1Id: partner1.id,\n          partner2Id: partner2.id,\n          themeId: themeIdNumber,\n          startDate: new Date(startDate),\n          endDate: new Date(endDate),\n          requestId: partner2RequestId,\n        },\n      });\n\n      pairings.push(pairing1);\n\n      // Create pairing where partner2 prays for partner1\n      const pairing2 = await prisma.prayerPairing.create({\n        data: {\n          partner1Id: partner2.id,\n          partner2Id: partner1.id,\n          themeId: themeIdNumber,\n          startDate: new Date(startDate),\n          endDate: new Date(endDate),\n          requestId: partner1RequestId,\n        },\n      });\n\n      pairings.push(pairing2);\n    }\n\n    sendSuccess(res, 201, `Successfully cleared ${deleteResult.count} existing pairings and created ${pairings.length} new prayer pairings`, {\n      clearedCount: deleteResult.count,\n      createdCount: pairings.length,\n      pairings: pairings.map(p => p.id)\n    });\n  } catch (error) {\n    console.error('Generate pairings error:', error);\n\n    if (error instanceof BadRequestError || error instanceof NotFoundError) {\n      sendError(res, error.statusCode, error.message);\n      return;\n    }\n\n    sendError(res, 500, 'Server error while generating pairings',\n      error instanceof Error ? error.message : 'Unknown error');\n  }\n};\n\n// Delete a pairing\nexport const deletePairing = async (req: Request, res: Response) => {\n  try {\n    if (!req.user) {\n      return sendError(res, 401, 'User not authenticated');\n    }\n    const { id } = req.params;\n\n    if (!id) {\n      throw new BadRequestError('Pairing ID is required');\n    }\n\n    const pairingId = toNumber(id);\n\n    if (pairingId === 0) {\n      throw new BadRequestError('Invalid pairing ID format');\n    }\n\n    // Check if pairing exists\n    const pairing = await prisma.prayerPairing.findUnique({\n      where: { id: pairingId },\n    });\n\n    if (!pairing) {\n      throw new NotFoundError('Prayer pairing');\n    }\n\n    await prisma.prayerPairing.delete({\n      where: { id: pairingId },\n    });\n\n    sendSuccess(res, 200, 'Prayer pairing deleted successfully');\n  } catch (error) {\n    console.error('Delete pairing error:', error);\n\n    if (error instanceof BadRequestError || error instanceof NotFoundError) {\n      sendError(res, error.statusCode, error.message);\n      return;\n    }\n\n    sendError(res, 500, 'Server error while deleting pairing',\n      error instanceof Error ? error.message : 'Unknown error');\n  }\n};\n\n// Export pairings to CSV\nexport const exportPairingsToCSV = async (req: Request, res: Response) => {\n  try {\n    if (!req.user) {\n      // Or check for admin role if this is an admin-only endpoint\n      return sendError(res, 401, 'User not authenticated');\n    }\n    // If this is an admin action, you might not need req.user.id directly here,\n    // but the check for req.user (and potentially req.user.role === 'ADMIN') is still good.\n    const userId = toNumber(req.params.userId || (req.user ? req.user.id : undefined));\n    if (isNaN(userId) && !req.params.userId) { // If not getting all pairings and user ID is not from an authenticated user\n        return sendError(res, 400, 'User ID is required to export pairings for a specific user.');\n    }\n\n    // Get filter parameters from query\n    const startDate = req.query.startDate ? new Date(req.query.startDate as string) : undefined;\n    const endDate = req.query.endDate ? new Date(req.query.endDate as string) : undefined;\n\n    // Build filter conditions\n    const whereCondition: any = {};\n    if (startDate) {\n      whereCondition.startDate = { gte: startDate };\n    }\n    if (endDate) {\n      whereCondition.endDate = { lte: endDate };\n    }\n\n    // Get pairings with filter\n    const pairings = await prisma.prayerPairing.findMany({\n      where: whereCondition,\n      include: {\n        partner1: {\n          select: {\n            firstName: true,\n            lastName: true,\n            email: true,\n            prayerRequests: {\n              where: { isActive: true },\n              orderBy: { createdAt: 'desc' },\n              take: 1,\n            },\n          },\n        },\n        partner2: {\n          select: {\n            firstName: true,\n            lastName: true,\n            email: true,\n            prayerRequests: {\n              where: { isActive: true },\n              orderBy: { createdAt: 'desc' },\n              take: 1,\n            },\n          },\n        },\n        theme: {\n          select: {\n            title: true,\n            description: true,\n          },\n        },\n        request: true,\n      },\n      orderBy: { startDate: 'desc' },\n    });\n\n    // Format data for CSV\n    const formattedData = pairings.map((pairing: PairingForExport) => ({\n      'Start Date': pairing.startDate.toLocaleDateString(),\n      'End Date': pairing.endDate.toLocaleDateString(),\n      'Partner 1 Name': `${pairing.partner1.firstName} ${pairing.partner1.lastName}`,\n      'Partner 1 Email': pairing.partner1.email,\n      'Partner 1 Prayer Request': pairing.partner1.prayerRequests.length > 0\n        ? pairing.partner1.prayerRequests[0].content\n        : 'None',\n      'Partner 2 Name': `${pairing.partner2.firstName} ${pairing.partner2.lastName}`,\n      'Partner 2 Email': pairing.partner2.email,\n      'Partner 2 Prayer Request': pairing.partner2.prayerRequests.length > 0\n        ? pairing.partner2.prayerRequests[0].content\n        : 'None',\n      'Prayer Theme': pairing.theme.title,\n      'Theme Description': pairing.theme.description,\n      'Special Pairing': pairing.isSpecialPairing ? 'Yes' : 'No',\n      'Assigned Prayer Request': pairing.request ? pairing.request.content : 'None',\n    }));\n\n    // Generate CSV\n    const fields = [\n      'Start Date',\n      'End Date',\n      'Partner 1 Name',\n      'Partner 1 Email',\n      'Partner 1 Prayer Request',\n      'Partner 2 Name',\n      'Partner 2 Email',\n      'Partner 2 Prayer Request',\n      'Prayer Theme',\n      'Theme Description',\n      'Special Pairing',\n      'Assigned Prayer Request'\n    ];\n\n    const json2csvParser = new Parser({ fields });\n    const csv = json2csvParser.parse(formattedData);\n\n    // Set headers for file download\n    res.setHeader('Content-Type', 'text/csv');\n    res.setHeader('Content-Disposition', 'attachment; filename=prayer-pairings.csv');\n\n    // Send CSV data\n    res.status(200).send(csv);\n  } catch (error) {\n    console.error('Export pairings to CSV error:', error);\n    res.status(500).json({ message: 'Server error while exporting pairings to CSV' });\n  }\n};\n\n// Clear all current pairings\nexport const clearAllPairings = async (req: Request, res: Response) => {\n  try {\n    // Get current date\n    const currentDate = new Date();\n    console.log('Clearing all current pairings as of:', currentDate);\n\n    // Find all current pairings\n    const currentPairings = await prisma.prayerPairing.findMany({\n      where: {\n        startDate: { lte: currentDate },\n        endDate: { gte: currentDate },\n      },\n    });\n\n    console.log(`Found ${currentPairings.length} current pairings to clear`);\n\n    if (currentPairings.length === 0) {\n      sendError(res, 404, 'No current pairings found to clear');\n      return;\n    }\n\n    // Delete all current pairings\n    const deleteResult = await prisma.prayerPairing.deleteMany({\n      where: {\n        startDate: { lte: currentDate },\n        endDate: { gte: currentDate },\n      },\n    });\n\n    console.log(`Successfully cleared ${deleteResult.count} prayer pairings`);\n    sendSuccess(res, 200, `Successfully cleared ${deleteResult.count} prayer pairings`, {\n      count: deleteResult.count\n    });\n  } catch (error) {\n    console.error('Clear all pairings error:', error);\n    sendError(res, 500, 'Server error while clearing pairings',\n      error instanceof Error ? error.message : 'Unknown error');\n  }\n};\n\n// Send emails to all paired partners\nexport const sendPartnerEmails = async (req: Request, res: Response) => {\n  try {\n    const { pairingIds } = req.body;\n\n    // If specific pairingIds are provided, use them, otherwise get all current pairings\n    const whereCondition: any = {};\n    if (pairingIds && pairingIds.length > 0) {\n      whereCondition.id = { in: pairingIds.map(Number) };\n    } else {\n      const currentDate = new Date();\n      whereCondition.startDate = { lte: currentDate };\n      whereCondition.endDate = { gte: currentDate };\n    }\n\n    // Get pairings\n    const pairings = await prisma.prayerPairing.findMany({\n      where: whereCondition,\n      include: {\n        partner1: true,\n        partner2: true,\n        theme: true,\n      },\n    });\n\n    if (pairings.length === 0) {\n      res.status(404).json({ message: 'No pairings found to send emails' });\n      return;\n    }\n\n    // Send emails to all partners\n    const emailResults = [];\n    for (const pairing of pairings) {\n      // Send email to partner1\n      const email1Result = await sendPrayerPartnerNotification(\n        pairing.partner1.email,\n        `${pairing.partner1.firstName} ${pairing.partner1.lastName}`,\n        `${pairing.partner2.firstName} ${pairing.partner2.lastName}`,\n        pairing.theme.title,\n        pairing.theme.description,\n        pairing.startDate,\n        pairing.endDate\n      );\n\n      // Update pairing with email sent status\n      await prisma.prayerPairing.update({\n        where: { id: pairing.id },\n        data: {\n          emailSent: true,\n          emailSentAt: new Date(),\n        },\n      });\n\n      emailResults.push({\n        pairingId: pairing.id,\n        partner1Email: pairing.partner1.email,\n        success: email1Result.success,\n        messageId: email1Result.messageId,\n        error: email1Result.error,\n      });\n    }\n\n    res.status(200).json({\n      message: `Successfully sent ${emailResults.length} emails to prayer partners`,\n      results: emailResults,\n    });\n  } catch (error) {\n    console.error('Send partner emails error:', error);\n    res.status(500).json({ message: 'Server error while sending partner emails' });\n  }\n};\n\n// Send reminder emails to all users to submit prayer requests\nexport const sendReminderEmails = async (req: Request, res: Response) => {\n  try {\n    // Get all active users\n    const activeUsers = await prisma.user.findMany({\n      where: { active: true },\n      select: {\n        id: true,\n        email: true,\n        firstName: true,\n        lastName: true\n      }\n    });\n\n    if (activeUsers.length === 0) {\n      sendError(res, 404, 'No active users found to send reminders');\n      return;\n    }\n\n    // Get current pairings to find the end date\n    const currentDate = new Date();\n    const currentPairings = await prisma.prayerPairing.findMany({\n      where: {\n        startDate: { lte: currentDate },\n        endDate: { gte: currentDate },\n      },\n      orderBy: { endDate: 'asc' },\n      take: 1,\n    });\n\n    if (currentPairings.length === 0) {\n      sendError(res, 404, 'No current pairings found to determine end date');\n      return;\n    }\n\n    const endDate = currentPairings[0].endDate;\n\n    // Send reminder emails using the email service\n    const result = await sendReminderEmailsCampaign(activeUsers, endDate);\n\n    if (result.success) {\n      sendSuccess(res, 200, `Sent reminder emails to ${result.successCount} of ${result.totalCount} users`, {\n        successCount: result.successCount,\n        totalCount: result.totalCount,\n        results: result.results\n      });\n    } else {\n      sendError(res, 500, 'Failed to send reminder emails', result.error?.message || 'Unknown error');\n    }\n  } catch (error) {\n    console.error('Send reminder emails error:', error);\n    sendError(res, 500, 'Server error while sending reminder emails',\n      error instanceof Error ? error.message : 'Unknown error');\n  }\n};\n\n// Send email to a specific pairing\nexport const sendEmailToPairing = async (req: Request, res: Response) => {\n  try {\n    const pairingId = toNumber(req.params.id);\n    const { customMessage } = req.body;\n\n    if (!pairingId) {\n      sendError(res, 400, 'Invalid pairing ID');\n      return;\n    }\n\n    // Get the pairing\n    const pairing = await prisma.prayerPairing.findUnique({\n      where: { id: pairingId },\n      include: {\n        partner1: true,\n        partner2: true,\n        theme: true,\n      },\n    });\n\n    if (!pairing) {\n      sendError(res, 404, 'Pairing not found');\n      return;\n    }\n\n    // Send email to partner1\n    const email1Result = await sendPrayerPartnerNotification(\n      pairing.partner1.email,\n      `${pairing.partner1.firstName} ${pairing.partner1.lastName}`,\n      `${pairing.partner2.firstName} ${pairing.partner2.lastName}`,\n      pairing.theme.title,\n      pairing.theme.description,\n      pairing.startDate,\n      pairing.endDate,\n      pairing.isSpecialPairing,\n      customMessage\n    );\n\n    // Update pairing with email sent status\n    await prisma.prayerPairing.update({\n      where: { id: pairingId },\n      data: {\n        emailSent: true,\n        emailSentAt: new Date(),\n      },\n    });\n\n    sendSuccess(res, 200, 'Email sent successfully', {\n      pairingId,\n      success: email1Result.success,\n      messageId: email1Result.messageId,\n    });\n  } catch (error) {\n    logger.error('Error sending email to pairing', { error, pairingId: req.params.id });\n    sendError(res, 500, 'Server error while sending email',\n      error instanceof Error ? error.message : 'Unknown error');\n  }\n};\n"
        }
    ]
}